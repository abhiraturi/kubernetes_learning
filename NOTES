Day 1:
 1018 kubectl get nodes
 1019  pwd
 1020  vim config.yaml
 1021  ll
 1022  ls -lrt
 1023  clear
 1024  kind create cluster --name cka-cluster2 --config config.yaml
 1025  kubectl get nodes
 1027   kubectl config get-contexts
 1028   kubectl config set-contexts kind-cka-cluster1 
 1029   kubectl config use-context kind-cka-cluster1 
 1030  kubectl get nodes
 1031   kubectl config use-context kind-cka-cluster2
 1032  kubectl get nodes

Day 2:
1060  kubectl run nginx --image=ngingx --dry-run=client
 1061  kubectl run nginx --image=ngingx --dry-run=client -o yaml
 1062  kubectl run nginx --image=ngingx --dry-run=client -o yaml > pod_new.yaml
 1063  ll
 1064  ls -lrt
 1065  cat pod_new.yaml
 1066  kubectl run nginx --image=ngingx --dry-run=client -o json > pod_new.json
 1067  ls -lrt
 1068  cat pod_new.json
 1069  kubectl get pods nginx-pod --show-labels
 1070  kubectl get pods nginx-pod -o wide
 1071  kubectl get pods  -o wide
 1072  kubectl get namespaces
 1073  kubectl get ns
 1074  kubectl get nodes
 1075  kubectl get nodes -o wide
kubectl describe pod nginx-ppod
kubectl delete pod nginx-ppod
kubectl create -f pods.yaml
kubectl exec -it nginx-pod -- /bin/sh


Day 3: Replication controller (replica set is the newer version, use replicates instead of replication controller now)
So,  with replicates you can manage the already running pods under the replicates using labels

1030  kubectl get po
 1031  kubectl delete po nginx-4h5md nginx-dbkm8 nginx-rzrkw
 1032  kubectl get po
 1033  kubectl get rs
 1034  kubectl get rc
 1035  kubectl delete rc nginx
 1036  kubectl get po
 1037  kubectl apply -f rc.yaml
 1038  vi rc.yaml
 1039  kubectl apply -f rc.yaml
 1040  kubectl get rs
 1041  kubectl get po
 1042  kubectl edit rs nginx
 1043  kubectl get po
 1044  kubectl get rs
 1045  kubectl delete rs/nginx
Kubectl delete rs nginx
Kubectl explain rs

Day 4: Deployment:
Deployment manages replicates and replicates manages pods. Deployment provides extra functionality.
e.g. if we want to upgrade image of nginx, if you do it using replicas set you will face downtime.
So, deployment makes changes in rolling manner, so there is no downtime.
Deployment creates  the replicaset and the replicaset creates the pods
So, if you want to change the image, you can do from below ways
Kubectl set image deploy/nginx-deploy nginx=nginx:1.9.1
Or directly edit the yaml file and apply 
Or directly update the deploy yaml manifest using command -> kubectl edit deployment/nginx-deploy

 1067  kubectl describe po nginx-deploy-7fff95c694-nvzng
 1068  kubectl describe deploy/nginx-deploy
 1069  kubectl describe deployment/nginx-deploy
 1070  kubectl describe deploy/nginx-deploy
 1073  kubectl rollout history deployment/nginx-deploy
 1074  kubectl rollout undo deployment/nginx-deploy
 1075  kubectl describe deploy/nginx-deploy
 1076  kubectl create deployment/nginx-deploy --dry-run=client
 1079  kubectl create deployment nginx-deploy --image=nginx --dry-run=client -o yaml
 1080  kubectl create deployment nginx-deploy --image=nginx --dry-run=client -o yaml > deployment.yaml
Kubectl explain deployment
Kubectl get all
Kubectl get po -o wide
kubectl delete deployment nginx-deploy


Day 5: services
We want to access this nginx frontend external, this can be done using services.
So, to make the application accessible to users and also to make the sure that the frontend pods are able to communicate with backend pods and external data sources we use services.

Users -> service -> frontend pods -> service -> backend pods -> service -> database

Different types of services:
1. Cluster ip
2. 2. Nodeport
3. External names
4. Load balancer


1049  kubect get svc
 1050  kubectl get svc
 1051  kubectl describe svc nodeport-svc
 1052  curl localhost:30001
 1053  curl localhost:3001


Day 6:  namespaces:
1115  k get deployment -n demo
 1116  k get po -n demo
 1117  k exec -it nginx-demo-87cd4cbb7-v7w8d -n demo /bin/bash
 1118  k get po -n demo -o wide
 1119  clear
 1120  k get deployment -n demo
 1121  k scale --replicas=3 deployment nginx-demo -n demo
 1122  k get deployment -n demo
 1123  k expose svc-demo deployment nginx-demo --port 80 -n demo
 1124  k expose deployment nginx-demo --name=svc-demo --port 80 -n demo
 1125  k get svc -n demo
 1126  k get po -n demo
 1127  k exec -it nginx-demo-87cd4cbb7-2bb6d /bin/sh
 1128  k exec -it nginx-demo-87cd4cbb7-2bb6d /bin/bash
 1129  k exec -it nginx-demo-87cd4cbb7-2bb6d -- /bin/bash
 1130  k exec -it nginx-demo-87cd4cbb7-2bb6d -n demo  /bin/bash


Day 7 : Multi container pod kubernetes
Pod will show up and running if all the init containers in that pod is running.

 1193  k get svc
 1194  k delete svc mydb
 1195  k get po
 1196  k delete po my-app
 1197  k get po
 1198  k delete po my-db-65776cb9c7-kh4m2 
 1199  k get po
 1200  k create -f multicontainerpod.yaml
 1201  k get po
 1202  k get svc
 1203  k get deployment
 1204  k get po
 1205  k get deployment
 1206  k expose deployment my-db  --name mydb --port 80
 1207  k get svc
 1208  k get po

Day 8 : Daemonset/cron job
Daemonset e.g. monitoring, logs, etc, only one runs per node.

1221  k apply -f daemonset.yaml
 1222  k get daemonset
 1223  k get nodes
 1224  k get po
 1225  k get daemonset -n kube-system


Day 9 : Manual scheduloing/ selectors/ labels
scheduler does not manage static pod but kubelet manages the static pods.
Pods can be scheduled manually by mentioning the node in the pods yaml file. So, even if the scheduler is down, the pods will still be scheduled in the node mentioned in the yaml file.
generally, the scheduler, api server, controller manager, etc yamls are under /etc/kubernetes/manifest directory in control plane node, these are called static pods.
This video is about scheduling and selecting pods in Kubernetes. The video starts with an introduction of the Kubernetes architecture and the role of the scheduler in assigning pods to nodes. The video then introduces the concept of static pods, which are control plane components that are not managed by the scheduler. The video also covers manual scheduling, which allows users to specify the node on which a pod should be scheduled. Finally, the video discusses labels and selectors, which are used to filter and group resources in Kubernetes.

 1257  k get ns
 1258  k get po --selector tier=backend -n demo
 1259  k get po
 1260  k describe po redis 
 1261  k get po --selector type=backend -n demo

 
